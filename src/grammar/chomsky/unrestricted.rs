use std::{collections::HashSet, fmt};

use super::Symbol;

/// Error type for unrestricted grammar validation.
///
/// This enum represents all possible errors that can occur when constructing
/// or validating an unrestricted grammar (Type-0 grammar in the Chomsky hierarchy).
#[derive(Debug, Clone)]
pub enum UnrestrictedError {
    StartSymbolNotFound { start_symbol: String },
    EmptyLhs { index: usize },
    LhsMissingNonTerminal { index: usize },
    NonTerminalNotFound { non_terminal: String },
    TerminalNotFound,
}

impl fmt::Display for UnrestrictedError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            UnrestrictedError::StartSymbolNotFound { start_symbol } => {
                write!(
                    f,
                    "Start symbol '{}' not found in non-terminals",
                    start_symbol
                )
            }
            UnrestrictedError::EmptyLhs { index } => {
                write!(f, "Production {} has empty left-hand side", index)
            }
            UnrestrictedError::LhsMissingNonTerminal { index } => {
                write!(
                    f,
                    "Production {} left-hand side must contain at least one non-terminal",
                    index
                )
            }
            UnrestrictedError::NonTerminalNotFound { non_terminal } => {
                write!(f, "Non-terminal '{}' not found in grammar", non_terminal)
            }
            UnrestrictedError::TerminalNotFound => {
                write!(f, "Terminal not found in grammar")
            }
        }
    }
}

impl std::error::Error for UnrestrictedError {}

/// An unrestricted grammar (Type-0 grammar in the Chomsky hierarchy).
///
/// Unrestricted grammars, also known as **recursively enumerable grammars** or
/// **phrase-structure grammars**, are the most powerful class of formal grammars
/// in the Chomsky hierarchy. They have no restrictions on the form of production
/// rules beyond requiring at least one non-terminal on the left-hand side.
///
/// # Grammar Form
///
/// Unrestricted grammars have productions of the form:
/// - α → β
///
/// where α and β are arbitrary strings of terminals and non-terminals, with the
/// only constraint being that α must contain at least one non-terminal. Unlike
/// context-sensitive grammars, β can be shorter than α, allowing string contraction.
///
/// # Computational Equivalence
///
/// Unrestricted grammars are **computationally equivalent to Turing machines**:
/// - Every language generated by an unrestricted grammar is recursively enumerable
/// - Every recursively enumerable language can be generated by an unrestricted grammar
/// - This makes them capable of describing any computation that can be performed
///   by a computer
///
/// # Properties
///
/// - **Recognition**: Recognized by Turing machines. The membership problem is
///   **undecidable** in general (there is no algorithm that can determine for
///   arbitrary grammar G and string w whether w ∈ L(G)).
/// - **Undecidable problems**: Many problems are undecidable for Type-0 grammars:
///   * Emptiness: Is L(G) = ∅?
///   * Equivalence: Does L(G₁) = L(G₂)?
///   * Ambiguity: Does the grammar have multiple derivations for some string?
///   * Intersection: Is L(G₁) ∩ L(G₂) = ∅?
/// - **Closure properties**: Closed under union, concatenation, Kleene star,
///   intersection, but NOT closed under complementation.
///
/// # Recursively Enumerable Languages
///
/// The languages generated by Type-0 grammars are exactly the recursively
/// enumerable (RE) languages, which include:
/// - All recursive (decidable) languages
/// - Some undecidable languages (e.g., the halting problem)
/// - Cannot include non-RE languages (e.g., the complement of the halting problem)
///
/// # Applications
///
/// While unrestricted grammars are theoretically important, they are rarely used
/// in practical applications due to undecidability. They serve primarily as:
/// - A theoretical model of computation
/// - A bridge between formal language theory and computability theory
/// - A reference point for understanding the limits of algorithmic processing
///
/// # Relationship to Other Grammar Types
///
/// - Most powerful type in the Chomsky hierarchy (Type-0)
/// - Properly contains context-sensitive languages (Type-1)
/// - Equivalent in power to Turing machines
/// - The hierarchy: Type-3 ⊂ Type-2 ⊂ Type-1 ⊂ Type-0
///
/// # Type Parameter
///
/// * `T` - The type of terminal symbols in the grammar. Must implement `Clone`, `Eq`,
///   and `Hash` to support efficient lookup and comparison operations.
#[derive(Debug, Clone)]
pub struct UnrestrictedGrammar<T: Clone + Eq + std::hash::Hash> {
    non_terminals: HashSet<String>,
    terminals: HashSet<T>,
    start_symbol: String,
    productions: Vec<UnrestrictedProduction<T>>,
}

/// A single production rule in an unrestricted grammar.
///
/// Represents a rewrite rule of the form `α → β` where:
/// - α (lhs) is a non-empty sequence of symbols with at least one non-terminal
/// - β (rhs) is any sequence of symbols (including empty, allowing contractions)
///
/// Unlike context-sensitive grammars, there is no length constraint between
/// left and right sides, enabling arbitrary string transformations including
/// deletions and contractions.
///
/// # Type Parameter
///
/// * `T` - The type of terminal symbols in the production.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnrestrictedProduction<T: Clone + Eq + std::hash::Hash> {
    lhs: Vec<Symbol<T>>,
    rhs: Vec<Symbol<T>>,
}

impl<T: Clone + Eq + std::hash::Hash> UnrestrictedGrammar<T> {
    /// Creates a new unrestricted grammar with validation.
    ///
    /// This constructor performs validation to ensure the grammar satisfies the
    /// minimal requirements of a Type-0 (unrestricted) grammar:
    ///
    /// 1. The start symbol must exist in the set of non-terminals
    /// 2. Production left-hand sides cannot be empty
    /// 3. Left-hand sides must contain at least one non-terminal (this is the
    ///    only restriction - the "non-terminal requirement")
    /// 4. All symbols must be defined in the grammar's alphabets
    ///
    /// Note that unlike context-sensitive grammars, there is NO length constraint
    /// between left and right sides, allowing productions like AB → a (contraction).
    ///
    /// # Arguments
    ///
    /// * `non_terminals` - Set of non-terminal symbols (variables)
    /// * `terminals` - Set of terminal symbols (alphabet)
    /// * `start_symbol` - The initial non-terminal for derivations
    /// * `productions` - Vector of production rules defining the grammar
    ///
    /// # Returns
    ///
    /// * `Ok(UnrestrictedGrammar)` - A validated unrestricted grammar
    /// * `Err(UnrestrictedError)` - Validation error with context
    ///
    /// # Errors
    ///
    /// Returns `UnrestrictedError` if:
    /// - Start symbol is not in the non-terminal set
    /// - Any production has an empty left-hand side
    /// - Any left-hand side lacks a non-terminal (LHS must have at least one)
    /// - Any symbol is not defined in the grammar
    ///
    /// # Theoretical Note
    ///
    /// Since unrestricted grammars are Turing-complete, many properties are
    /// undecidable. This constructor only validates structural properties, not
    /// semantic ones like language emptiness or equivalence.
    ///
    /// # Examples
    ///
    /// ```
    /// use grammatica::grammar::chomsky::{UnrestrictedGrammar, UnrestrictedProduction, Symbol};
    /// use std::collections::HashSet;
    ///
    /// // Unrestricted grammar with contraction: AB → c (|lhs| > |rhs|)
    /// let grammar = UnrestrictedGrammar::new(
    ///     HashSet::from(["S".to_string(), "A".to_string(), "B".to_string()]),
    ///     HashSet::from(['a', 'c']),
    ///     "S".to_string(),
    ///     vec![
    ///         UnrestrictedProduction::new(
    ///             vec![Symbol::NonTerminal("S".to_string())],
    ///             vec![Symbol::Terminal('a'), Symbol::NonTerminal("A".to_string()), Symbol::NonTerminal("B".to_string())]
    ///         ),
    ///         // Contraction: AB → c (not allowed in context-sensitive!)
    ///         UnrestrictedProduction::new(
    ///             vec![Symbol::NonTerminal("A".to_string()), Symbol::NonTerminal("B".to_string())],
    ///             vec![Symbol::Terminal('c')]
    ///         ),
    ///     ]
    /// ).unwrap();
    /// ```
    pub fn new(
        non_terminals: HashSet<String>,
        terminals: HashSet<T>,
        start_symbol: String,
        productions: Vec<UnrestrictedProduction<T>>,
    ) -> Result<Self, UnrestrictedError> {
        if !non_terminals.contains(&start_symbol) {
            return Err(UnrestrictedError::StartSymbolNotFound { start_symbol });
        }
        for (i, prod) in productions.iter().enumerate() {
            if prod.lhs.is_empty() {
                return Err(UnrestrictedError::EmptyLhs { index: i });
            }
            let has_non_terminal = prod.lhs.iter().any(|s| matches!(s, Symbol::NonTerminal(_)));
            if !has_non_terminal {
                return Err(UnrestrictedError::LhsMissingNonTerminal { index: i });
            }
            for symbol in prod.lhs.iter().chain(prod.rhs.iter()) {
                match symbol {
                    Symbol::NonTerminal(nt) => {
                        if !non_terminals.contains(nt) {
                            return Err(UnrestrictedError::NonTerminalNotFound {
                                non_terminal: nt.clone(),
                            });
                        }
                    }
                    Symbol::Terminal(t) => {
                        if !terminals.contains(t) {
                            return Err(UnrestrictedError::TerminalNotFound);
                        }
                    }
                }
            }
        }
        Ok(Self {
            non_terminals,
            terminals,
            start_symbol,
            productions,
        })
    }

    pub fn non_terminals(&self) -> &HashSet<String> {
        &self.non_terminals
    }
    pub fn terminals(&self) -> &HashSet<T> {
        &self.terminals
    }
    pub fn start_symbol(&self) -> &String {
        &self.start_symbol
    }
    pub fn productions(&self) -> &Vec<UnrestrictedProduction<T>> {
        &self.productions
    }
    pub fn into_parts(
        self,
    ) -> (
        HashSet<String>,
        HashSet<T>,
        String,
        Vec<UnrestrictedProduction<T>>,
    ) {
        (
            self.non_terminals,
            self.terminals,
            self.start_symbol,
            self.productions,
        )
    }
}

impl<T: Clone + Eq + std::hash::Hash> UnrestrictedProduction<T> {
    pub fn new(lhs: Vec<Symbol<T>>, rhs: Vec<Symbol<T>>) -> Self {
        Self { lhs, rhs }
    }
    pub fn lhs(&self) -> &Vec<Symbol<T>> {
        &self.lhs
    }
    pub fn rhs(&self) -> &Vec<Symbol<T>> {
        &self.rhs
    }
    pub fn into_parts(self) -> (Vec<Symbol<T>>, Vec<Symbol<T>>) {
        (self.lhs, self.rhs)
    }
}

impl<T: Clone + Eq + std::hash::Hash> From<super::ContextSensitiveGrammar<T>>
    for UnrestrictedGrammar<T>
{
    /// Converts a context-sensitive grammar to an unrestricted grammar.
    ///
    /// Every context-sensitive grammar is an unrestricted grammar, so this conversion
    /// always succeeds. The productions are directly compatible as context-sensitive
    /// grammars are a proper subset of unrestricted grammars.
    fn from(csg: super::ContextSensitiveGrammar<T>) -> Self {
        let (non_terminals, terminals, start_symbol, cs_productions) = csg.into_parts();
        let productions = cs_productions
            .into_iter()
            .map(|prod| UnrestrictedProduction {
                lhs: prod.lhs().clone(),
                rhs: prod.rhs().clone(),
            })
            .collect();
        UnrestrictedGrammar {
            non_terminals,
            terminals,
            start_symbol,
            productions,
        }
    }
}
